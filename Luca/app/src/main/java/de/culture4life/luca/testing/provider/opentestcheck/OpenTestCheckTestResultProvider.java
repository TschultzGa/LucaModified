package de.culture4life.luca.testing.provider.opentestcheck;

import com.google.android.gms.common.util.Hex;

import android.util.Base64;

import com.auth0.jwt.JWT;
import com.auth0.jwt.JWTVerifier;
import com.auth0.jwt.algorithms.Algorithm;
import com.nexenio.rxkeystore.RxKeyStore;
import com.nexenio.rxkeystore.provider.hash.RxHashProvider;
import com.nexenio.rxkeystore.provider.hash.Sha256HashProvider;

import de.culture4life.luca.registration.RegistrationData;
import de.culture4life.luca.testing.TestResultParsingException;
import de.culture4life.luca.testing.TestResultVerificationException;
import de.culture4life.luca.testing.provider.TestResultProvider;

import java.nio.charset.StandardCharsets;
import java.security.KeyFactory;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.X509EncodedKeySpec;

import androidx.annotation.NonNull;
import io.reactivex.rxjava3.core.BackpressureStrategy;
import io.reactivex.rxjava3.core.Completable;
import io.reactivex.rxjava3.core.Maybe;
import io.reactivex.rxjava3.core.Observable;
import io.reactivex.rxjava3.core.Single;

import static de.culture4life.luca.testing.TestResultVerificationException.Reason.INVALID_SIGNATURE;
import static de.culture4life.luca.testing.TestResultVerificationException.Reason.NAME_MISMATCH;

public class OpenTestCheckTestResultProvider extends TestResultProvider<OpenTestCheckTestResult> {

    private static final String URL_PREFIX_TESTVERIFY_IO = "https://testverify.io/v1#";
    private static final RxHashProvider HASH_PROVIDER = new Sha256HashProvider(new RxKeyStore());
    protected static final String ENCODED_TICKET_IO_PUBLIC_KEY = "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAqImfTl5rpFHeCM/cjAgeMS8mfhxGxO3+dss+1jidKRJ7ta2fOIQ6k1wPLtqh8U2HHIITXY8Atrlh81s9bSGeJIL9VY/QDeJgqwU147eDLqpO/iF4LvKa13bats+WzN2vXU9vPtk3WNRXh5SktbdMnmK49l20TgjzPac1ES3tv7MSExeF6Bq9zPrG47mUJW+Fm8AH7nID5kBYFosMcsRNVmY4PNYCYM7q17Cc/S/MjFZD+f4mzYLRnMbZs7IjLBGlrood21XHTNt1G6/1f4peA6EWCgKbCgbwdCIHl/wn/ktWOjxoAogX3oRcKOhhCcgt+7ReY8mj2exrTypmN3TscQIDAQAB";
    protected static final String ENCODED_SODA_PUBLIC_KEY = "MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAu7TJ7bLhg3tvgXwnnTx8IFL80/qGDIuctJR/HN0EzooYooMJi0tauRvokbKOqZ40bPahOUMZheeaueKkzSEyfjqPAXOSNzBe9ltgHQcDWjKUuMIaTJW5w2nJncR5UAOFmuqY8aL5IInu/vVgTjP/mXqWN5JKiEGpA3R7UNn0RWFdU6HJ4qq1n52hyUNFF4bRTQHqkw3fnJEMTOqubo4StBX2GMO8F/pCn4UA8+nhzHbtvE1QE4R+ibxs2zbGwDFL5EFDdbqvLULeMfSys5pUDgx7z04oaSzh/MYvtApqOv3dxHi8HkBlCXNUMjUD6EWukcWn4IFHC9MAKzYq4JcfANNjka5ug5LUuL84GcITKqeesZzbSSUU3/OTRk4yri7QbbNKfbv3+E9rUpcQhVTVNdBo3jxqmCm25GjwmYWTLE9++UT4IiUid3Y6kAC+Xeiz2Q+9bXszj6tME1WrhKCAc6dvM6vM3neYul5xnI/K1CSq7lB8KDxCS1//7FT6EIDa4+UVSONkTrVzaVexQgt/fMO3c5TadjS8KN3Gml0DIhzahAXzp+CJ+0xgQqsTcoujRfnVCw2d3YLP6x8JKG4vPikYUhOJ1NEBuAJv1Ict1uFuIoClaw1TkoDeUU4rPcemSOb3JXRKZeIQrRGU9vOzNVfCViDYkiE3X/IbmedhTEUCAwEAAQ==";
    protected static final String ENCODED_MEIN_CORONA_TEST_PUBLIC_KEY = "MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAqefCWY5KQ6K6KYI4ioALntTWIXOpL5HU4Obh645VIY9q2gFl959I2XzNvKhqMNgvlbj91bY0Y8vQmGVVKyJs9BvKNi9TmjGBU6Jn88TP//jmi4K24QQ+PeqT2O+Jz8wnhQoW/tf9TJa7In31HJcDWkLK7USrLPyRL4vaosOPcBIRTCK0KrjZbEYikXBotiXHUIGNmlRRJzOoWYB8asDVDT+3GTKMXvOxIxRebdvkmRRUl0Wl/+oKlit6fN8XmgGxiJtFVaWMI0dec+afPJwmoGrNSiX9WlvV37x0qefWOc8AGauQ7HxmCq+RK7qz6+cRvo1xEXKcw/GDiXXKwZpOcBUogNee4fDR+WoF8auoCyisRKkqCFqZh09A8goiV3aqAK2JYNxgULoYZ/1BnFX/zldpD6PY+UGcb8RErfXs4Lj88bEBlm/aOs3n4N5yt3866ylOMofLFA2nl27857s/wwFpF0uD8AlBy3GynNFOLxOsCrnZULs/ipZbiBtmX5x71kydOldoQQF+Yrc1XKqZ62+MK9xIQIcvKk/azb7LGG8SWiHW4EbvmPzPSP6QqZslfLRbXcpc8g4ZCRNYHAfNGPwxqjQRNwTKYwPK4lFjqoI3dVrkCVI1hfEpXdBKBQ5TientoC82eeitiFaQIG5yXNnWAmf3gxDX4AltBsVafLsCAwEAAQ==";
    protected static final String ENCODED_DM_PUBLIC_KEY = "MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA2Qg6eu+5MLfs8XZosUUOyHenh51zI4RtaXrHdNhVpHiadTO48rQU9GvDJIM6qoNFWtWMak+kvxp9qYQrCtt7YoL74GagTxhK9g4wOvBV/8AYW/asSRslpFhNi0nlKujiSdf9aKlmUouRSYO200+/8XFz+YRYhL31Srv8xEAuHjLk2wI4/d56FkjMWOxMV7aO4ClicR8WfUZzod779VpCtZY6kkhHLppQ2elLviK2SX5WjPq6srWgCYi3B0aWb/qvM1/gMs7/T/zz9WXJJeMCpElcRWVtbmYsn12wx1hZtn9RdlfpVFnQCbE8WvcvttqPspr2Z0TLgusO+1z7RiayqHVM+ai5uoAOptq4LwkJ6Hls2Aaa9+fx58lrtZ6QCK2J8aSY8z59NFeRJUMfZmTffYNG4gR9rE0hNe+u1Tg+HfFHLpPM62u3D1eCkzw7OlBaRUVlYL7LLir+WT5LP7sL2DaY2WauK6QSI603sO14c3Y8upX3SySLfjryPctzOXv0oH0RG/M2YAbX9KEImw9cYrEJjx7H9tL7QEQ1ufTh2aIeB66uiTV/Ek/lCiVuGefI2Eg0dR3iiuWXfxoqJN8f1KZoaKeIAK6V2Zf+EG15R6ClEqobGryGvcoKfpeJe0KaQSsDQ2RuveGff8Wz6qbPwu9Jvb2i++mfx1Nr22ubjwsCAwEAAQ==";
    protected static final String ENCODED_TEST_NOW_PUBLIC_KEY = "MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA2f7iILA7fFDXXjZSdVknvahoMrmExeB5S06E4KXKUogpkoe6AlkEQJJUhqmUrbIGBsrcSj09rz8WbArXRkGXp3WZELl4kOK/441KW5HAA9hXlXyrgdajCKfofg5CdaXhlvMotL2wBa7JKg/jCy/q1jFS78s8AzrU/CMQ/3w1PCAdRmiOpVLqz66D6+fliAz11Om8GLQUR6S9HN00hI00waxbTGwQ2d8bzXyF2V8hNa2Z3IdYkacvLRnEe4Lr66E0mqzLM0I+H12I23tiC0l7Pw/Nt8KD40zHbwfzuVQ+2K4cazsB3PJInl8HR5n2lqrTxTutm/NQGngtDWxVptnbdqDszrPGsS8OvJmt7cBWJDIV3bMvAmWW9IY3OLj8S707Cx/OETBj2d+nEbyNM2Kb9GLsYwTBIwZHmAo//uYjCyAVXgLnWyN495JZWKPJSsbSpjckqElfOVouJ+wqR+emjCRjOa5o2XH+iU+Aqca8o9c6yO8IxNkKuxTJuZri6rB3hqz3DT9GuRSI7UYHnisYeXAS1OPcEirqZrFP3jqeDaY8tCTtocqNsKD15oLLpFJrhhIG0Y2UwIY2f+WQflh9ySxtjmRGHArmWobmaBiKG0DcycD4nPbJbiNOwWRpWC0JNh6QzreAb2kxsc1rhFOATVMnSOJij3CQPgKi0+GdFmECAwEAAQ==";
    protected static final String ENCODED_COSIAMA_PUBLIC_KEY = "MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEArCAGvkp40A1W7g+dYBmdKlv4cozfsCQFRgwtq7FGd2ZN9DxRzKp0Wqv1PXuAoUyJm9PKQJjWvelf3w8ciPLYAsdsICSFFgaVpUeQxdob+D0ls9/q4B4u6nFR9te0EOwVLNJvxnBtXjkwNPOYiS9N6qsJ74gubj+VUpwJC9glSDK5DIi1p99Z/NLLiioxT0MvFr5Cr69N93d2ROemK5o+PbaPQyfrqW1DYawgZAHzx2gMiajS3lUQflwi78d0ZLWIYtSK8ynTZko7/CK3YD+jXoYrX+BIhri4j3P7KEVW2v7k94xsAl4zYeCnV9YWFgj5P9aipWS8kd6BJJkhpzfXdlm9XGOQurOXzcoumARcMxIcKSdm7daCONCFfGBpwfK1pBVHUtymEjGrgO0BLajb3F9WtTyAPCR/8QEXHeHzdi7/SlmpTq75MV0po85JhBz2cw3J4T94ERX76EfqE+F5zODj1AncMK+IiWXf7ToJkioRhPoQRUaeDuQ0RMNsdzoeNCeW+vz9ENtQaOQxKYne2655XQ470c8kBJPT0faW42CPDPA5X0k6F7oAjQxPYsWDp19V4oSYzgiF4zEk45ZcqnLTsjQTOAqNWSIN7H/OFguoadNaZssBD1k5XvRgq391QL7lQyoae47I/523e2/Xc7tLF66gTsK4F6PhD/1gOf8CAwEAAQ==";
    protected static final String ENCODED_DRK_HANNOVER_PUBLIC_KEY = "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwCFC6kbek4KHCWdBATlZj5ARDXrBW9DLuANucicBTX3LwR4l24L4l/1kei+nBuagVk2KbZpAAVP3ygQ8UehnYCSap1TBLalRn5KAwzGUax+c2TmDmbnFZu957soChtA7cH4Ka1JdaQftcvoL+DghrOSw5jZ47AOJ6LeJ6ZITvU5i9krT3nM6Z9GtmG57QqTRwLVPGNB6PbQg18Ype6cZuCiqmukWtHDVWzi21wA/oZ/2KZUGmI5a46Zc2QqAK4PMfms2DsrIVn+0vcPTUjB5h1wzgvr1S/AD0yMYWmLjyW4QL3/y6uBLW1nTGpFVZ3uNmsGpsFBfrGb9YIBztGK09wIDAQAB";
    protected static final String ENCODED_PROBATIX_PUBLIC_KEY = "MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAtErrLxCO1CVCYIK0iOSCyxgoqtVd8Dml8SyFt8fMKAf3sr0qhaekncCpJ9NeUEuyyD6lgJGMqka97chZHLDbSsZvahyB7mII694yaiSsRmtWnll9Gw53xT4Mvo9ATMOUq15DSHRNoVyteM+1xjNbthyQigm7/ekPfqzeLPKleszRf0yoMHpZBUH5BrSEeq34u7GpdyMlWztlttM8YYjVvnV2MUF4sIh6lGRnSp1iFDCu3sRNvM7E+UZIQVi0Mz/VxyJ2AHoIToI4Bc0PNoj92W48z/I5cBW9ZfSTljk4i51s8N56A5xiewMqW4loS6Peclyk4O1/pO1F6UjdJia1shdSK7DFh/hQdcP+8wTr/GBWUhwNzvO8WzyC7lvqasHw+E0kUW7+lGJcTsUtQqZdNUzN0CKtfIEf6KXs+jHPXojdc2eHkvc0+5OkfkEWdmLeywoP4q1CMuwntv02K/ydRvCFUsule6oYvfQY+AHb2BIFyJIBC9C67nPE/zWZPa1ExEPXWOTbG/NkL6WMQa8wLD7HFsuLzAtkGK+UmM8+E7Oukrv/0tT8wX/X0U1E3ZvJ3VRNWXiQ36MFsNeLviukUSlcdNBMOsyswwQX2fLFOC9EmX+WHDNuO3Q3RAaG5CBVVPb+R3jXR8Dd5afX86/AJuRXRrRFme/OR8UHfpDY5rsCAwEAAQ==";

    private RSAPublicKey ticketIoKey;
    private RSAPublicKey sodaKey;
    private RSAPublicKey meinCoronaTestKey;
    private RSAPublicKey dmKey;
    private RSAPublicKey testNowKey;
    private RSAPublicKey cosiamaKey;
    private RSAPublicKey drkHannoverKey;
    private RSAPublicKey probatixKey;

    @Override
    public Single<Boolean> canParse(@NonNull String encodedData) {
        return getEncodedJwtWithoutUrl(encodedData)
                .map(JWT::decode)
                .map(decodedJWT -> true)
                .onErrorReturnItem(false);
    }

    @Override
    public Single<OpenTestCheckTestResult> parse(@NonNull String encodedData) {
        return getEncodedJwtWithoutUrl(encodedData)
                .map(OpenTestCheckTestResult::new)
                .onErrorResumeNext(throwable -> Single.error(new TestResultParsingException(throwable)));
    }

    @Override
    public Completable validate(@NonNull OpenTestCheckTestResult testResult, @NonNull RegistrationData registrationData) {
        return verifyNameHash(testResult.n, registrationData);
    }

    @Override
    public Completable verify(@NonNull String encodedData) {
        return Maybe.mergeDelayError(getPublicKeys()
                .map(publicKey -> getEncodedJwtWithoutUrl(encodedData)
                        .flatMapMaybe(jwt -> verifyJwt(jwt, publicKey)
                                .andThen(Maybe.just(publicKey))
                                .onErrorResumeWith(Maybe.empty())))
                .toFlowable(BackpressureStrategy.BUFFER))
                .firstOrError()
                .ignoreElement()
                .onErrorResumeNext(throwable -> Completable.error(new TestResultVerificationException(INVALID_SIGNATURE, throwable)));
    }

    private Completable verifyJwt(@NonNull String jwt, @NonNull RSAPublicKey publicKey) {
        return Completable.fromAction(() -> {
            Algorithm algorithm = Algorithm.RSA256(publicKey, null);
            JWTVerifier verifier = JWT.require(algorithm).build();
            verifier.verify(jwt);
        }).onErrorResumeNext(throwable -> Completable.error(new TestResultVerificationException(INVALID_SIGNATURE, throwable)));
    }

    private Completable verifyNameHash(@NonNull String expectedNameHash, @NonNull RegistrationData registrationData) {
        return generateNameHash(registrationData)
                .flatMapCompletable(actualNameHash -> Completable.fromAction(() -> {
                    if (!actualNameHash.equals(expectedNameHash)) {
                        throw new IllegalArgumentException("Name hash mismatch");
                    }
                })).onErrorResumeNext(throwable -> Completable.error(new TestResultVerificationException(NAME_MISMATCH, throwable)));
    }

    private Single<String> generateNameHash(@NonNull RegistrationData registrationData) {
        return Single.fromCallable(() -> {
            String name = registrationData.getFirstName() + registrationData.getLastName();
            name = name.toUpperCase();
            name = name.replaceAll("[^\\x00-\\x7F]", "");
            name = name.replaceAll("/[^\\x41-\\x5A]/", "");
            return name.getBytes(StandardCharsets.US_ASCII);
        }).flatMap(HASH_PROVIDER::hash).map(Hex::bytesToStringLowercase);
    }

    private Single<String> getEncodedJwtWithoutUrl(@NonNull String encodedData) {
        return Single.fromCallable(() -> {
            if (encodedData.startsWith(URL_PREFIX_TESTVERIFY_IO)) {
                return encodedData.substring(URL_PREFIX_TESTVERIFY_IO.length());
            } else {
                return encodedData;
            }
        });
    }

    private Observable<RSAPublicKey> getPublicKeys() {
        return Single.mergeArray(
                getTicketIoKey(),
                getSodaPublicKey(),
                getMeinCoronaTestPublicKey(),
                getDmPublicKey(),
                getTestNowPublicKey(),
                getCosiamaPublicKey(),
                getDrkHannoverPublicKey(),
                getProbatixPublicKey()
        ).toObservable();
    }

    private Single<RSAPublicKey> getTicketIoKey() {
        return Maybe.fromCallable(() -> ticketIoKey)
                .switchIfEmpty(decodePublicKey(ENCODED_TICKET_IO_PUBLIC_KEY)
                        .doOnSuccess(decodedPublicKey -> this.ticketIoKey = decodedPublicKey));
    }

    private Single<RSAPublicKey> getSodaPublicKey() {
        return Maybe.fromCallable(() -> sodaKey)
                .switchIfEmpty(decodePublicKey(ENCODED_SODA_PUBLIC_KEY)
                        .doOnSuccess(decodedPublicKey -> this.sodaKey = decodedPublicKey));
    }

    private Single<RSAPublicKey> getMeinCoronaTestPublicKey() {
        return Maybe.fromCallable(() -> meinCoronaTestKey)
                .switchIfEmpty(decodePublicKey(ENCODED_MEIN_CORONA_TEST_PUBLIC_KEY)
                        .doOnSuccess(decodedPublicKey -> this.meinCoronaTestKey = decodedPublicKey));
    }

    private Single<RSAPublicKey> getDmPublicKey() {
        return Maybe.fromCallable(() -> dmKey)
                .switchIfEmpty(decodePublicKey(ENCODED_DM_PUBLIC_KEY)
                        .doOnSuccess(decodedPublicKey -> this.dmKey = decodedPublicKey));
    }

    private Single<RSAPublicKey> getTestNowPublicKey() {
        return Maybe.fromCallable(() -> testNowKey)
                .switchIfEmpty(decodePublicKey(ENCODED_TEST_NOW_PUBLIC_KEY)
                        .doOnSuccess(decodedPublicKey -> this.testNowKey = decodedPublicKey));
    }

    private Single<RSAPublicKey> getCosiamaPublicKey() {
        return Maybe.fromCallable(() -> cosiamaKey)
                .switchIfEmpty(decodePublicKey(ENCODED_COSIAMA_PUBLIC_KEY)
                        .doOnSuccess(decodedPublicKey -> this.cosiamaKey = decodedPublicKey));
    }

    private Single<RSAPublicKey> getDrkHannoverPublicKey() {
        return Maybe.fromCallable(() -> drkHannoverKey)
                .switchIfEmpty(decodePublicKey(ENCODED_DRK_HANNOVER_PUBLIC_KEY)
                        .doOnSuccess(decodedPublicKey -> this.drkHannoverKey = decodedPublicKey));
    }

    private Single<RSAPublicKey> getProbatixPublicKey() {
        return Maybe.fromCallable(() -> probatixKey)
                .switchIfEmpty(decodePublicKey(ENCODED_PROBATIX_PUBLIC_KEY)
                        .doOnSuccess(decodedPublicKey -> this.probatixKey = decodedPublicKey));
    }

    private Single<RSAPublicKey> decodePublicKey(@NonNull String encodedPublicKey) {
        return Single.fromCallable(() -> {
            byte[] encoded = Base64.decode(encodedPublicKey, Base64.NO_WRAP);
            KeyFactory keyFactory = KeyFactory.getInstance("RSA");
            return (RSAPublicKey) keyFactory.generatePublic(new X509EncodedKeySpec(encoded));
        });
    }

}
