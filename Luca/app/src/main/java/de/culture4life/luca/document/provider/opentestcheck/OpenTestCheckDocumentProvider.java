package de.culture4life.luca.document.provider.opentestcheck;

import static de.culture4life.luca.document.DocumentVerificationException.Reason.INVALID_SIGNATURE;
import static de.culture4life.luca.document.DocumentVerificationException.Reason.NAME_MISMATCH;

import android.text.TextUtils;
import android.util.Base64;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import com.google.android.gms.common.util.Hex;
import com.nexenio.rxkeystore.RxKeyStore;
import com.nexenio.rxkeystore.provider.hash.RxHashProvider;
import com.nexenio.rxkeystore.provider.hash.Sha256HashProvider;

import java.nio.charset.StandardCharsets;
import java.security.KeyFactory;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.X509EncodedKeySpec;

import de.culture4life.luca.document.DocumentManager;
import de.culture4life.luca.document.DocumentParsingException;
import de.culture4life.luca.document.DocumentVerificationException;
import de.culture4life.luca.document.provider.DocumentProvider;
import de.culture4life.luca.network.pojo.DocumentProviderData;
import de.culture4life.luca.registration.Person;
import de.culture4life.luca.util.JwtUtil;
import io.jsonwebtoken.Jwts;
import io.reactivex.rxjava3.core.BackpressureStrategy;
import io.reactivex.rxjava3.core.Completable;
import io.reactivex.rxjava3.core.Maybe;
import io.reactivex.rxjava3.core.Observable;
import io.reactivex.rxjava3.core.Single;
import timber.log.Timber;

public class OpenTestCheckDocumentProvider extends DocumentProvider<OpenTestCheckDocument> {

    private static final String URL_PREFIX_TESTVERIFY_IO = "https://testverify.io/v1#";
    protected static final RxHashProvider HASH_PROVIDER = new Sha256HashProvider(new RxKeyStore());

    private final DocumentManager documentManager;

    @Nullable
    private DocumentProviderData lastVerifiedProviderData;

    public OpenTestCheckDocumentProvider(@NonNull DocumentManager documentManager) {
        this.documentManager = documentManager;
    }

    @Override
    public Single<Boolean> canParse(@NonNull String encodedData) {
        return getEncodedJwtWithoutUrl(encodedData)
                .flatMap(OpenTestCheckDocumentProvider::isJwt)
                .onErrorReturnItem(false);
    }

    @Override
    public Single<OpenTestCheckDocument> parse(@NonNull String encodedData) {
        return getEncodedJwtWithoutUrl(encodedData)
                .map(OpenTestCheckDocument::new)
                .flatMap(openTestCheckDocument -> getProviderName(openTestCheckDocument)
                        .map(providerName -> {
                            openTestCheckDocument.getDocument().setProvider(providerName);
                            return openTestCheckDocument;
                        }))
                .onErrorResumeNext(throwable -> Single.error(new DocumentParsingException(throwable)));
    }

    @Override
    protected Completable validateName(@NonNull OpenTestCheckDocument document, @NonNull Person person) {
        return verifyNameHash(document.n, person)
                .andThen(validateTime(document.getDocument().getTestingTimestamp()));
    }

    @Override
    public Completable verify(@NonNull String encodedData) {
        return Maybe.mergeDelayError(getDocumentProviderData(encodedData)
                .flatMapSingle(documentProviderData -> decodePublicKey(documentProviderData.getPublicKey())
                        .map(publicKey -> getEncodedJwtWithoutUrl(encodedData)
                                .flatMapMaybe(jwt -> verifyJwt(jwt, publicKey)
                                        .andThen(Maybe.just(documentProviderData))
                                        .onErrorResumeWith(Maybe.empty()))))
                .toFlowable(BackpressureStrategy.BUFFER))
                .firstOrError()
                .doOnSubscribe(disposable -> lastVerifiedProviderData = null)
                .doOnSuccess(documentProviderData -> {
                    Timber.d("Verified using public key from %s", documentProviderData.getName());
                    lastVerifiedProviderData = documentProviderData;
                })
                .ignoreElement()
                .onErrorResumeNext(throwable -> Completable.error(new DocumentVerificationException(INVALID_SIGNATURE, throwable)));
    }

    private Completable verifyJwt(@NonNull String jwt, @NonNull RSAPublicKey publicKey) {
        return Completable.fromAction(() -> Jwts.parserBuilder()
                .setSigningKey(publicKey)
                .build()
                .parseClaimsJws(jwt))
                .onErrorResumeNext(throwable -> Completable.error(new DocumentVerificationException(INVALID_SIGNATURE, throwable)));
    }

    private Completable verifyNameHash(@NonNull String expectedNameHash, @NonNull Person person) {
        return generateNameHash(person)
                .flatMapCompletable(actualNameHash -> Completable.fromAction(() -> {
                    if (!actualNameHash.equals(expectedNameHash)) {
                        throw new IllegalArgumentException("Name hash mismatch");
                    }
                })).onErrorResumeNext(throwable -> Completable.error(new DocumentVerificationException(NAME_MISMATCH, throwable)));
    }

    protected Single<String> generateNameHash(@NonNull Person person) {
        return Single.fromCallable(() -> Person.Companion.simplify(person.getFullName()).getBytes(StandardCharsets.US_ASCII))
                .flatMap(HASH_PROVIDER::hash).map(Hex::bytesToStringLowercase);
    }

    private Single<String> getEncodedJwtWithoutUrl(@NonNull String encodedData) {
        return Single.fromCallable(() -> {
            if (encodedData.startsWith(URL_PREFIX_TESTVERIFY_IO)) {
                return encodedData.substring(URL_PREFIX_TESTVERIFY_IO.length());
            } else {
                return encodedData;
            }
        });
    }

    private Single<String> getProviderName(@NonNull OpenTestCheckDocument openTestCheckDocument) {
        return Maybe.defer(() -> {
            if (TextUtils.isEmpty(openTestCheckDocument.f)) {
                return Maybe.fromCallable(() -> lastVerifiedProviderData);
            }
            return documentManager.restoreDocumentProviderDataListIfAvailable()
                    .flatMapObservable(Observable::fromIterable)
                    .filter(documentProviderData -> documentProviderData.getFingerprint().equals(openTestCheckDocument.f))
                    .firstElement();
        }).toSingle()
                .onErrorReturnItem(new DocumentProviderData(openTestCheckDocument.l, "", ""))
                .map(DocumentProviderData::getName);
    }

    private Observable<DocumentProviderData> getDocumentProviderData(@NonNull String encodedJwt) {
        return Single.fromCallable(() -> OpenTestCheckDocument.getFingerprint(encodedJwt))
                .flatMapObservable(documentManager::getDocumentProviderData);
    }

    private static Single<RSAPublicKey> decodePublicKey(@NonNull String encodedPublicKey) {
        return Single.fromCallable(() -> {
            byte[] encoded = Base64.decode(encodedPublicKey, Base64.NO_WRAP);
            KeyFactory keyFactory = KeyFactory.getInstance("RSA");
            return (RSAPublicKey) keyFactory.generatePublic(new X509EncodedKeySpec(encoded));
        });
    }

    private static Single<Boolean> isJwt(String jwt) {
        return Single.fromCallable(() -> Jwts.parserBuilder()
                .build()
                .parseClaimsJwt(JwtUtil.getUnsignedJwt(jwt)))
                .map(headerClaimsJwt -> true)
                .onErrorReturnItem(false);
    }

}
